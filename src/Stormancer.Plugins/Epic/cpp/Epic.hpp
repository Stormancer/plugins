#pragma once

#include "Friends/Friends.hpp"
#include "Party/Party.hpp"
#include "Users/Users.hpp"

#include "stormancer/Configuration.h"
#include "stormancer/IPlugin.h"
#include "stormancer/IScheduler.h"
#include "stormancer/StormancerTypes.h"
#include "stormancer/Utilities/PointerUtilities.h"
#include "stormancer/Utilities/TaskUtilities.h"
#include "stormancer/cpprestsdk/cpprest/asyncrt_utils.h"
#include "stormancer/Utilities/JsonSerializer.h"

// https://dev.epicgames.com/docs/services/en-US/index.html

namespace Stormancer
{
	namespace EpicGames
	{
		static constexpr const char* platformName = "epicGames";

		/// <summary>
		/// Keys to use in Configuration::additionalParameters map to customize the EpicGames plugin behavior.
		/// </summary>
		namespace ConfigurationKeys
		{
			/// <summary>
			/// Enable the EpicGames authentication.
			/// If disabled, the EpicGames plugin will not initiate any authentications.
			/// Default is "true".
			/// Use "false" to disable.
			/// </summary>
			constexpr const char* AuthenticationEnabled = "epicGames.authentication.enabled";

			/// <summary>
			/// A game client launched from the Epic Games Store will authenticate with Epic's authorization server using a one-time use exchange code.
			/// This exchange code is generated by the Epic Launcher and passed to the game client as a command-line argument.
			/// </summary>
			constexpr const char* ExchangeCode = "epicGames.authentication.exchangeCode";

			constexpr const char* ClientId = "epicGames.authentication.clientId";

			constexpr const char* ClientSecret = "epicGames.authentication.clientSecret";
		}

		constexpr const char* PARTY_TYPE_EPICGAMESIDLOBBY = "epicGamesIDLobby";

		using EpicGamesID = uint64;
		using EpicGamesIDLobby = uint64;
		using EpicGamesIDFriend = uint64;
		using EpicGamesIDApp = uint64;

		struct LobbyMember
		{
			EpicGamesID epicGamesID;
			std::string personaname;
			std::unordered_map<std::string, std::string> data;
		};

		struct Lobby
		{
			EpicGamesIDLobby epicGamesIDLobby = 0;
			int numLobbyMembers = 0;
			int lobbyMemberLimit = 0;
			EpicGamesID lobbyOwner = 0;
			std::unordered_map<EpicGamesID, LobbyMember> lobbyMembers;
			std::unordered_map<std::string, std::string> data;
		};

		struct LobbyFilter
		{
			ELobbyDistanceFilter distanceFilter = ELobbyDistanceFilter::k_ELobbyDistanceFilterDefault;
			int slotsAvailable = 0;
			int resultCountFilter = 0;
			std::vector<std::pair<std::string, int>> nearValueFilter;
			std::unordered_map<std::string, std::pair<int, ELobbyComparison>> numericalFilter;
			std::unordered_map<std::string, std::pair<std::string, ELobbyComparison>> stringFilter;
		};

		struct PartyDataDto
		{
			std::string partyId;
			std::string leaderUserId;
			EpicGamesID leaderEpicGamesId = 0;

			MSGPACK_DEFINE(partyId, leaderUserId, leaderEpicGamesId);
		};

		struct EpicGamesFriend
		{
			std::string epicGamesId;
			std::string relationship;
			uint64 friend_since = 0;

			MSGPACK_DEFINE(epicGamesId, relationship, friend_since);
		};

		class EpicGamesApi
		{
		public:

			static constexpr const char* METADATA_KEY = "stormancer.plugins.epicGames";

			virtual ~EpicGamesApi() = default;

			virtual void initialize() = 0;

			// Stormancer Api

			virtual pplx::task<std::unordered_map<std::string, PartyDataDto>> decodePartyDataBearerTokens(const std::unordered_map<std::string, std::string>& partyDataBearerToken, pplx::cancellation_token ct = pplx::cancellation_token::none()) = 0;

			virtual pplx::task<std::unordered_map<EpicGamesID, std::string>> queryUserIds(const std::vector<EpicGamesID>& epicGamesIDs, pplx::cancellation_token ct = pplx::cancellation_token::none()) = 0;

			virtual pplx::task<bool> inLobby(EpicGamesIDLobby epicGamesIDLobby, pplx::cancellation_token ct = pplx::cancellation_token::none()) = 0;

			virtual pplx::task<bool> isOwner(EpicGamesIDLobby epicGamesIDLobby, pplx::cancellation_token ct = pplx::cancellation_token::none()) = 0;

			virtual pplx::task<std::vector<EpicGamesFriend>> getFriends(int friendsFlag = k_EFriendFlagImmediate, uint32 maxFriendsCount = UINT32_MAX, pplx::cancellation_token ct = pplx::cancellation_token::none()) = 0;

			virtual Event<EpicGamesIDLobby>& getJoinLobbyEvent() = 0;

			// EpicGames Api

			virtual pplx::task<RequestAccessTokenResponse> requestAccessToken(const std::string& exchangeCode) = 0;

			virtual pplx::task<void> revokeAccessToken(const std::string& accessToken) = 0;

			virtual EpicGamesID getEpicGamesID() = 0;

			virtual pplx::task<EpicGamesIDLobby> createLobby(ELobbyType lobbyType = ELobbyType::k_ELobbyTypeFriendsOnly, int maxMembers = 5, bool joinable = true, const std::unordered_map<std::string, std::string> metadata = std::unordered_map<std::string, std::string>(), pplx::cancellation_token ct = pplx::cancellation_token::none()) = 0;

			virtual pplx::task<void> joinLobby(EpicGamesIDLobby epicGamesIDLobby, pplx::cancellation_token ct = pplx::cancellation_token::none()) = 0;

			virtual pplx::task<void> leaveLobby(EpicGamesIDLobby epicGamesIDLobby, pplx::cancellation_token ct = pplx::cancellation_token::none()) = 0;

			virtual pplx::task<Lobby> requestLobbyData(EpicGamesIDLobby epicGamesIDLobby, pplx::cancellation_token ct = pplx::cancellation_token::none()) = 0;

			virtual pplx::task<std::vector<Lobby>> requestLobbyList(LobbyFilter lobbyFilter = LobbyFilter(), pplx::cancellation_token ct = pplx::cancellation_token::none()) = 0;

			virtual pplx::task<void> setLobbyJoinable(EpicGamesIDLobby epicGamesIDLobby, bool joinable, pplx::cancellation_token ct = pplx::cancellation_token::none()) = 0;

			virtual pplx::task<void> setLobbyData(EpicGamesIDLobby epicGamesIDLobby, const std::string& key, const std::string& value, pplx::cancellation_token ct = pplx::cancellation_token::none()) = 0;

			virtual pplx::task<void> setLobbyMemberData(EpicGamesIDLobby epicGamesIDLobby, const std::string& key, const std::string& value, pplx::cancellation_token ct = pplx::cancellation_token::none()) = 0;

			// EpicGames Utils

			virtual EpicGamesIDApp getAppId() = 0;
		};

		namespace details
		{
			class EpicGamesPlatformUserId : public Users::PlatformUserId
			{
			public:

				std::string type() const override
				{
					return platformName;
				}

				static std::shared_ptr<EpicGamesPlatformUserId> create(EpicGamesID epicGamesID)
				{
					// No make_shared because this class constructor is private
					return std::shared_ptr<EpicGamesPlatformUserId>(new EpicGamesPlatformUserId(epicGamesID));
				}

				static std::shared_ptr<EpicGamesPlatformUserId> tryCast(std::shared_ptr<Users::PlatformUserId> id)
				{
					if (id != nullptr && id->type() == platformName)
					{
						return std::static_pointer_cast<EpicGamesPlatformUserId>(id);
					}
					return nullptr;
				}

				EpicGamesID getEpicGamesID()
				{
					return _epicGamesID;
				}

				bool operator==(const EpicGamesPlatformUserId& right)
				{
					return _epicGamesID == right._epicGamesID;
				}

				bool operator!=(const EpicGamesPlatformUserId& right)
				{
					return _epicGamesID != right._epicGamesID;
				}

			private:

				EpicGamesPlatformUserId(EpicGamesID epicGamesID)
					: PlatformUserId(std::to_string(epicGamesID))
					, _epicGamesID(epicGamesID)
				{
				}

				const EpicGamesID _epicGamesID;
			};

			class EpicGamesConfiguration
			{
			public:

				EpicGamesConfiguration(std::shared_ptr<Configuration> config)
				{
					_authenticationEnabled = config->additionalParameters.find(ConfigurationKeys::AuthenticationEnabled) != config->additionalParameters.end() ? (config->additionalParameters.at(ConfigurationKeys::AuthenticationEnabled) != "false") : true;
					_exchangeCode = config->additionalParameters.find(ConfigurationKeys::ExchangeCode) != config->additionalParameters.end() ? config->additionalParameters.at(ConfigurationKeys::ExchangeCode) : "";
					_clientId = config->additionalParameters.find(ConfigurationKeys::ClientId) != config->additionalParameters.end() ? config->additionalParameters.at(ConfigurationKeys::ClientId) : "";
					_clientSecret = config->additionalParameters.find(ConfigurationKeys::ClientSecret) != config->additionalParameters.end() ? config->additionalParameters.at(ConfigurationKeys::ClientSecret) : "";
				}

				bool getAuthenticationEnabled() const
				{
					return _authenticationEnabled;
				}

				std::string getExchangeCode() const
				{
					return _exchangeCode;
				}

				void resetExchangeCode()
				{
					_exchangeCode = "";
				}

				std::string getClientId() const
				{
					return _clientId;
				}

				std::string getClientSecret() const
				{
					return _clientSecret;
				}

			private:

				bool _authenticationEnabled = true;
				std::string _exchangeCode;
				const std::string _clientId;
				const std::string _clientSecret;
			};

			struct CreateLobbyDto
			{
				ELobbyType lobbyType = ELobbyType::k_ELobbyTypePrivate;
				int maxMembers = 0;
				bool joinable = false;
				std::unordered_map<std::string, std::string> metadata;

				MSGPACK_DEFINE(lobbyType, maxMembers, joinable, metadata)
			};

			struct JoinLobbyDto
			{
				EpicGamesIDLobby epicGamesIDLobby;

				MSGPACK_DEFINE(epicGamesIDLobby)
			};

			class EpicGamesService : public std::enable_shared_from_this<EpicGamesService>
			{
			public:

				EpicGamesService(std::shared_ptr<Scene> scene)
					: _rpcService(scene->dependencyResolver().resolve<RpcService>())
				{
				}

				pplx::task<std::unordered_map<std::string, PartyDataDto>> decodePartyDataBearerTokens(const std::unordered_map<std::string, std::string>& partyDataBearerTokens, pplx::cancellation_token ct = pplx::cancellation_token::none())
				{
					return _rpcService->rpc<std::unordered_map<std::string, PartyDataDto>>("EpicGames.DecodePartyDataBearerTokens", ct, partyDataBearerTokens);
				}

				pplx::task<std::unordered_map<EpicGamesID, std::string>> queryUserIds(const std::vector<EpicGamesID>& epicGamesIDs, pplx::cancellation_token ct = pplx::cancellation_token::none())
				{
					return _rpcService->rpc<std::unordered_map<EpicGamesID, std::string>>("EpicGames.QueryUserIds", ct, epicGamesIDs);
				}

			private:

				std::shared_ptr<RpcService> _rpcService;
			};

			class EpicGamesPartyService : public std::enable_shared_from_this<EpicGamesPartyService>
			{
			public:

				EpicGamesPartyService(std::shared_ptr<Scene> scene)
					: _rpcService(scene->dependencyResolver().resolve<RpcService>())
				{
				}

				pplx::task<std::string> createPartyDataBearerToken(pplx::cancellation_token ct = pplx::cancellation_token::none())
				{
					return _rpcService->rpc<std::string>("EpicGamesParty.CreatePartyDataBearerToken", ct);
				}

			private:

				std::shared_ptr<RpcService> _rpcService;
			};

			class EpicGamesPartyInvitation : public Party::Platform::IPlatformInvitation
			{
			public:

				EpicGamesPartyInvitation(const std::string& senderId)
					: _senderId(senderId)
				{
				}

				pplx::task<Party::PartyId> accept(std::shared_ptr<Party::PartyApi>) override
				{
					throw std::runtime_error("Not implemented");
				}

				pplx::task<void> decline(std::shared_ptr<Party::PartyApi>) override
				{
					throw std::runtime_error("Not implemented");
				}

				std::string getSenderId() override
				{
					return _senderId;
				}

				std::string getSenderPlatformId() override
				{
					throw std::runtime_error("Not implemented");
				}

				std::string getSenderUsername() override
				{
					throw std::runtime_error("Not implemented");
				}

			private:

				std::string _senderId;
			};

			class EpicGamesPartyProvider;

			class EpicGamesImpl : public ClientAPI<EpicGamesImpl, EpicGamesService>, public EpicGamesApi
			{
				friend class EpicGamesPartyProvider;

			public:

#pragma region public_methods

				EpicGamesImpl(std::shared_ptr<Users::UsersApi> usersApi, std::shared_ptr<EpicGamesConfiguration> epicGamesConfig, std::shared_ptr<Configuration> config, std::shared_ptr<IScheduler> scheduler, std::shared_ptr<ILogger> logger, std::shared_ptr<Party::PartyApi> partyApi)
					: ClientAPI(usersApi, "stormancer.epicGames")
					, _wEpicGamesConfig(epicGamesConfig)
					, _wScheduler(scheduler)
					, _wActionDispatcher(config->actionDispatcher)
					, _logger(logger)
					, _wUsersApi(usersApi)
					, _wPartyApi(partyApi)
				{
				}

				~EpicGamesImpl()
				{
					_cts.cancel();
				}

				void initialize() override
				{
					if (auto epicGamesConfig = _wEpicGamesConfig.lock())
					{
						if (epicGamesConfig->getEpicGamesApiInitialize())
						{
							if (!EpicGamesAPI_Init())
							{
								_logger->log(LogLevel::Error, "EpicGames", "EpicGamesAPI_Init failed");
								return;
							}
						}

						if (epicGamesConfig->getEpicGamesApiRunCallbacks())
						{
							scheduleRunEpicGamesAPiCallbacks();
						}
					}

					auto usersApi = _wUsersApi.lock();
					if (!usersApi)
					{
						_logger->log(LogLevel::Error, "EpicGames", "UsersApi deleted");
						return;
					}

					auto wEpicGamesImpl = STORM_WEAK_FROM_THIS();

					usersApi->setOperationHandler("EpicGames.GetFriends", [wEpicGamesApi = wEpicGamesImpl, wUsersApi = _wUsersApi, logger = _logger](Stormancer::Users::OperationCtx& ctx)
					{
						auto epicGamesApi = wEpicGamesApi.lock();
						if (!epicGamesApi)
						{
							STORM_RETURN_TASK_FROM_EXCEPTION(ObjectDeletedException("EpicGamesApi"), void);
						}

						uint32 maxFriendsCount = ctx.request->readObject<uint32>();

						return epicGamesApi->getFriends(k_EFriendFlagImmediate, maxFriendsCount, ctx.request->cancellationToken())
							.then([ctx](std::vector<EpicGamesFriend> friends)
						{
							ctx.request->sendValueTemplated(friends);
						});
					});

					usersApi->setOperationHandler("EpicGames.CreateLobby", [wEpicGamesImpl, wUsersApi = _wUsersApi, logger = _logger](Stormancer::Users::OperationCtx& ctx)
					{
						auto epicGamesImpl = wEpicGamesImpl.lock();
						if (!epicGamesImpl)
						{
							STORM_RETURN_TASK_FROM_EXCEPTION(ObjectDeletedException("EpicGamesApi"), void);
						}

						auto createLobbyDto = ctx.request->readObject<CreateLobbyDto>();

						// Create lobby
						return epicGamesImpl->createLobby(createLobbyDto.lobbyType, createLobbyDto.maxMembers, createLobbyDto.joinable, createLobbyDto.metadata, ctx.request->cancellationToken())
							.then([wEpicGamesImpl, wUsersApi, ctx](EpicGamesIDLobby epicGamesIDLobby)
						{
							auto epicGamesImpl = wEpicGamesImpl.lock();
							if (!epicGamesImpl)
							{
								STORM_RETURN_TASK_FROM_EXCEPTION(ObjectDeletedException("EpicGamesApi"), void);
							}

							auto usersApi = wUsersApi.lock();
							if (!usersApi)
							{
								STORM_RETURN_TASK_FROM_EXCEPTION(ObjectDeletedException("UsersApi"), void);
							}

							{
								std::lock_guard<std::recursive_mutex> lg(epicGamesImpl->_mutex);

								// Keep epicGamesIDLobby to leave on party leave
								epicGamesImpl->_partyEpicGamesIDLobby = epicGamesIDLobby;
							}

							auto myUserId = usersApi->userId();

							return epicGamesImpl->setLobbyMemberData(epicGamesIDLobby, "stormancer.userId", myUserId, ctx.request->cancellationToken())
								.then([epicGamesIDLobby, ctx]()
							{
								// Send back epicGamesIDLobby to server
								ctx.request->sendValue([epicGamesIDLobby](obytestream& stream)
								{
									Serializer serializer;
									serializer.serialize(stream, epicGamesIDLobby);
								});
							});
						});
					});

					usersApi->setOperationHandler("EpicGames.JoinLobby", [wEpicGamesImpl, wUsersApi = _wUsersApi, logger = _logger](Stormancer::Users::OperationCtx& ctx)
					{
						auto epicGamesImpl = wEpicGamesImpl.lock();
						if (!epicGamesImpl)
						{
							STORM_RETURN_TASK_FROM_EXCEPTION(ObjectDeletedException("EpicGamesApi"), void);
						}

						auto joinLobbyDto = ctx.request->readObject<JoinLobbyDto>();
						auto epicGamesIDLobby = joinLobbyDto.epicGamesIDLobby;

						std::lock_guard<std::recursive_mutex> lg(epicGamesImpl->_mutex);

						// Keep epicGamesIDLobby to leave on party leave
						epicGamesImpl->_partyEpicGamesIDLobby = epicGamesIDLobby;

						return epicGamesImpl->inLobby(epicGamesIDLobby, ctx.request->cancellationToken())
							.then([epicGamesIDLobby, wEpicGamesImpl, ctx](bool inLobby)
						{
							if (inLobby)
							{
								// We already are in the lobby, do nothing
								return pplx::task_from_result();
							}
							else
							{
								// Join lobby
								auto epicGamesImpl = wEpicGamesImpl.lock();
								if (!epicGamesImpl)
								{
									STORM_RETURN_TASK_FROM_EXCEPTION(ObjectDeletedException("EpicGamesApi"), void);
								}

								return epicGamesImpl->joinLobby(epicGamesIDLobby, ctx.request->cancellationToken());
							}
						})
							.then([wEpicGamesImpl, wUsersApi, epicGamesIDLobby, ctx]()
						{
							auto epicGamesImpl = wEpicGamesImpl.lock();
							if (!epicGamesImpl)
							{
								STORM_RETURN_TASK_FROM_EXCEPTION(ObjectDeletedException("EpicGamesApi"), void);
							}

							auto usersApi = wUsersApi.lock();
							if (!usersApi)
							{
								STORM_RETURN_TASK_FROM_EXCEPTION(ObjectDeletedException("UsersApi"), void);
							}

							auto myUserId = usersApi->userId();
							return epicGamesImpl->setLobbyMemberData(epicGamesIDLobby, "stormancer.userId", myUserId, ctx.request->cancellationToken());
						});
					});
				}

				void scheduleRunEpicGamesAPiCallbacks()
				{
					if (!_cts.get_token().is_canceled())
					{
						EpicGamesAPI_RunCallbacks();

						if (auto actionDispatcher = _wActionDispatcher.lock())
						{
							auto wEpicGamesImpl = STORM_WEAK_FROM_THIS();
							actionDispatcher->post([wEpicGamesImpl]()
							{
								if (auto epicGamesImpl = wEpicGamesImpl.lock())
								{
									epicGamesImpl->scheduleRunEpicGamesAPiCallbacks();
								}
							});
						}
					}
				}

				class RequestAccessTokenResponse
				{
				public:

					std::string access_token;
					
					uint32 expires_in;

					std::string expires_at;

					std::string account_id;

					std::string client_id;

					std::string application_id;

					std::string token_type;

					std::string refresh_token;

					std::string refresh_expires_in;

					std::string refresh_expires_at;

					JSON_SERIALIZER(access_token, expires_in, expires_at, account_id, client_id, application_id, token_type, refresh_token, refresh_expires_in, refresh_expires_at);
				};

				std::string generateFormUrlEncodedBody(const std::unordered_map<std::string, std::string>& data)
				{
					std::stringstream ss;
					bool appendAnd = false;
					for (auto& pair : data)
					{
						if (appendAnd)
						{
							ss << '&';
						}
						else
						{
							appendAnd = true;
						}
						ss << web::uri::encode_uri(pair.first()) << '=' << web::uri::encode_uri(pair.second());
					}
					return ss.str();
				}
				
				pplx::task<RequestAccessTokenResponse> requestAccessToken(const std::string& exchangeCode) override
				{
					web::http::client::http_client client(utility::conversions::to_string_t("https://api.epicgames.dev"));
					web::http::client::http_request request(web::http::methods::POST);
					request.set_request_uri(utility::conversions::to_string_t("/epic/oauth/v1/token"));
					request.headers().add(_XPLATSTR("Content-Type"), _XPLATSTR("application/x-www-form-urlencoded"));
					request.headers().add(_XPLATSTR("Accept"), _XPLATSTR("application/json"));
					request.headers().add(_XPLATSTR("x-version"), _XPLATSTR("3"));
					var bodyStr = generateFormUrlEncodedBody({
						{ "grant_type", "exchange_code" },
						{ "deployment_id", "XXXXXX" },
						{ "scope", "basic_profile friends_list presence" },
						{ "exchange_code", exchangeCode }
					});
					request.set_body(utility::conversions::to_string_t(bodyStr));

					return client.request(request)
						.then([](http_response response)
					{
						RequestAccessTokenResponse response;
						JsonSerializer::deserialize(response.body(), response);
						return response;
					});
				}
				
				pplx::task<void> revokeAccessToken(const std::string& accessToken) override
				{
					web::http::client::http_client client(utility::conversions::to_string_t("https://api.epicgames.dev"));
					web::http::client::http_request request(web::http::methods::POST);
					request.set_request_uri(utility::conversions::to_string_t("/epic/oauth/v1/revoke"));
					request.headers().add(_XPLATSTR("Content-Type"), _XPLATSTR("application/x-www-form-urlencoded"));
					request.headers().add(_XPLATSTR("Accept"), _XPLATSTR("application/json"));
					request.headers().add(_XPLATSTR("x-version"), _XPLATSTR("3"));
					request.headers().add(_XPLATSTR("Authorization"), utility::conversions::to_string_t("Bearer " + accessToken));
					request.set_body(utility::string_t());

					return client.request(request)
						.then([](http_response response) {});
				}

				EpicGamesID getEpicGamesID() override
				{
					auto epicGamesUser = EpicGamesUser();

					auto epicGamesID = epicGamesUser->GetEpicGamesID();

					return epicGamesID.ConvertToUint64();
				}

				pplx::task<EpicGamesIDLobby> createLobby(ELobbyType lobbyType = ELobbyType::k_ELobbyTypeFriendsOnly, int maxMembers = 5, bool joinable = true, const std::unordered_map<std::string, std::string> metadata = std::unordered_map<std::string, std::string>(), pplx::cancellation_token ct = pplx::cancellation_token::none()) override
				{
					auto actionDispatcher = _wActionDispatcher.lock();
					auto taskOptions = actionDispatcher ? pplx::task_options(actionDispatcher) : pplx::task_options();

					if (maxMembers < 1 || maxMembers > 250)
					{
						STORM_RETURN_TASK_FROM_EXCEPTION_OPT(std::runtime_error("maxMembers must be between 1 and 250"), taskOptions, EpicGamesIDLobby);
					}

					auto epicGamesMatchmaking = EpicGamesMatchmaking();
					if (!epicGamesMatchmaking)
					{
						STORM_RETURN_TASK_FROM_EXCEPTION_OPT(std::runtime_error("EpicGamesMatchmaking() returned null"), taskOptions, EpicGamesIDLobby);
					}

					_logger->log(LogLevel::Trace, "EpicGames", "Create lobby");

					std::lock_guard<std::recursive_mutex> lg(_mutex);

					// Cancel
					if (_lobbyCreatedTce)
					{
						_lobbyCreatedCallResult.Cancel();
						_lobbyCreatedTce->set_exception(pplx::task_canceled());
					}

					// Prepare
					_lobbyCreatedTce = std::make_shared<pplx::task_completion_event<EpicGamesIDLobby>>();

					// Timeout
					timeout(10s, ct)
						.register_callback([tce = _lobbyCreatedTce]()
					{
						tce->set_exception(pplx::task_canceled());
					});

					// Call EpicGamesAPI and register call result
					EpicGamesAPICall_t hEpicGamesAPICall = epicGamesMatchmaking->CreateLobby(lobbyType, maxMembers);
					_lobbyCreatedCallResult.Set(hEpicGamesAPICall, this, &EpicGamesImpl::onLobbyCreatedCallResult);

					return pplx::create_task(*_lobbyCreatedTce, taskOptions)
						.then([epicGamesMatchmaking, joinable, metadata, wEpicGamesApi = STORM_WEAK_FROM_THIS(), logger = _logger, ct](EpicGamesIDLobby epicGamesIDLobby)
					{
						auto epicGamesApi = wEpicGamesApi.lock();

						auto task = pplx::task_from_result();

						if (!joinable)
						{
							epicGamesApi->setLobbyJoinable(epicGamesIDLobby, joinable, ct)
								.then([logger](pplx::task<void> task)
							{
								try
								{
									return task.get();
								}
								catch (const std::exception& ex)
								{
									logger->log(LogLevel::Warn, "EpicGames", "setLobbyJoinable failed", ex);
								}
							});
						}

						if (metadata.size() > 0)
						{
							for (auto& md : metadata)
							{
								epicGamesApi->setLobbyData(epicGamesIDLobby, md.first, md.second, ct)
									.then([logger](pplx::task<void> task)
								{
									try
									{
										return task.get();
									}
									catch (const std::exception& ex)
									{
										logger->log(LogLevel::Warn, "EpicGames", "setLobbyData failed, metadata ignored", ex);
									}
								});
							}
						}

						return epicGamesIDLobby;
					});
				}

				pplx::task<void> joinLobby(EpicGamesIDLobby epicGamesIDLobby, pplx::cancellation_token ct = pplx::cancellation_token::none()) override
				{
					auto actionDispatcher = _wActionDispatcher.lock();
					auto taskOptions = actionDispatcher ? pplx::task_options(actionDispatcher) : pplx::task_options();

					auto epicGamesMatchmaking = EpicGamesMatchmaking();
					if (!epicGamesMatchmaking)
					{
						STORM_RETURN_TASK_FROM_EXCEPTION_OPT(std::runtime_error("EpicGamesMatchmaking() returned null"), actionDispatcher, void);
					}

					_logger->log(LogLevel::Trace, "EpicGames", "Join lobby", std::to_string(epicGamesIDLobby));

					std::lock_guard<std::recursive_mutex> lg(_mutex);

					// Cancel
					auto it = _lobbyEnterEventData.find(epicGamesIDLobby);
					if (it != _lobbyEnterEventData.end())
					{
						it->second.callResult.Cancel();
						it->second.tce.set_exception(pplx::task_canceled());
						_lobbyEnterEventData.erase(it);
					}

					// Prepare
					auto& lobbyEnterEventData = _lobbyEnterEventData[epicGamesIDLobby];

					// Timeout
					timeout(10s, ct)
						.register_callback([tce = lobbyEnterEventData.tce]()
					{
						tce.set_exception(pplx::task_canceled());
					});

					// Call EpicGamesAPI and register call result
					EpicGamesAPICall_t hEpicGamesAPICall = epicGamesMatchmaking->JoinLobby(CEpicGamesID(epicGamesIDLobby));
					lobbyEnterEventData.callResult.Set(hEpicGamesAPICall, this, &EpicGamesImpl::onLobbyEnterCallResult);

					return pplx::create_task(lobbyEnterEventData.tce, taskOptions);
				}

				pplx::task<void> leaveLobby(EpicGamesIDLobby epicGamesIDLobby, pplx::cancellation_token ct = pplx::cancellation_token::none()) override
				{
					auto actionDispatcher = _wActionDispatcher.lock();
					auto taskOptions = actionDispatcher ? pplx::task_options(actionDispatcher) : pplx::task_options();

					auto epicGamesMatchmaking = EpicGamesMatchmaking();
					if (!epicGamesMatchmaking)
					{
						STORM_RETURN_TASK_FROM_EXCEPTION_OPT(std::runtime_error("EpicGamesMatchmaking() returned null"), actionDispatcher, void);
					}

					if (ct.is_cancelable() && ct.is_canceled())
					{
						STORM_RETURN_TASK_CANCELED_OPT(actionDispatcher, void);
					}

					_logger->log(LogLevel::Trace, "EpicGames", "Leave lobby", std::to_string(epicGamesIDLobby));

					epicGamesMatchmaking->LeaveLobby(CEpicGamesID(epicGamesIDLobby));

					_logger->log(LogLevel::Trace, "EpicGames", "Lobby left", std::to_string(epicGamesIDLobby));

					return pplx::task_from_result(taskOptions);
				}

				pplx::task<std::vector<Lobby>> requestLobbyList(LobbyFilter lobbyFilter = LobbyFilter(), pplx::cancellation_token ct = pplx::cancellation_token::none()) override
				{
					auto actionDispatcher = _wActionDispatcher.lock();
					auto taskOptions = actionDispatcher ? pplx::task_options(actionDispatcher) : pplx::task_options();

					auto epicGamesMatchmaking = EpicGamesMatchmaking();
					if (!epicGamesMatchmaking)
					{
						STORM_RETURN_TASK_FROM_EXCEPTION_OPT(std::runtime_error("EpicGamesMatchmaking() returned null"), taskOptions, std::vector<Lobby>);
					}

					_logger->log(LogLevel::Trace, "EpicGames", "requestLobbyList");

					if (lobbyFilter.distanceFilter != ELobbyDistanceFilter::k_ELobbyDistanceFilterDefault)
					{
						epicGamesMatchmaking->AddRequestLobbyListDistanceFilter(lobbyFilter.distanceFilter);
					}

					if (lobbyFilter.slotsAvailable > 0)
					{
						epicGamesMatchmaking->AddRequestLobbyListFilterSlotsAvailable(lobbyFilter.slotsAvailable);
					}

					if (lobbyFilter.resultCountFilter > 0)
					{
						epicGamesMatchmaking->AddRequestLobbyListResultCountFilter(lobbyFilter.distanceFilter);
					}

					for (auto& nearValueFilter : lobbyFilter.nearValueFilter)
					{
						epicGamesMatchmaking->AddRequestLobbyListNearValueFilter(nearValueFilter.first.c_str(), nearValueFilter.second);
					}

					for (auto& numericalFilter : lobbyFilter.numericalFilter)
					{
						epicGamesMatchmaking->AddRequestLobbyListNumericalFilter(numericalFilter.first.c_str(), numericalFilter.second.first, numericalFilter.second.second);
					}

					for (auto& stringFilter : lobbyFilter.stringFilter)
					{
						epicGamesMatchmaking->AddRequestLobbyListStringFilter(stringFilter.first.c_str(), stringFilter.second.first.c_str(), stringFilter.second.second);
					}

					std::lock_guard<std::recursive_mutex> lg(_mutex);

					// Cancel
					if (_requestLobbyListTce)
					{
						_requestLobbyListCallResult.Cancel();
						_requestLobbyListTce->set_exception(pplx::task_canceled());
					}

					// Prepare
					_requestLobbyListTce = std::make_shared<pplx::task_completion_event<std::vector<Lobby>>>();

					// Timeout
					timeout(10s, ct)
						.register_callback([tce = _requestLobbyListTce]()
					{
						tce->set_exception(pplx::task_canceled());
					});

					// Call EpicGamesAPI and register call result
					EpicGamesAPICall_t hEpicGamesAPICall = epicGamesMatchmaking->RequestLobbyList();
					_requestLobbyListCallResult.Set(hEpicGamesAPICall, this, &EpicGamesImpl::onRequestLobbyListCallResult);

					return pplx::create_task(*_requestLobbyListTce, taskOptions);
				}

				pplx::task<void> setLobbyJoinable(EpicGamesIDLobby epicGamesIDLobby, bool joinable, pplx::cancellation_token ct = pplx::cancellation_token::none()) override
				{
					auto actionDispatcher = _wActionDispatcher.lock();
					auto taskOptions = actionDispatcher ? pplx::task_options(actionDispatcher) : pplx::task_options();

					auto epicGamesMatchmaking = EpicGamesMatchmaking();
					if (!epicGamesMatchmaking)
					{
						STORM_RETURN_TASK_FROM_EXCEPTION_OPT(std::runtime_error("EpicGamesMatchmaking() returned null"), taskOptions, void);
					}

					if (ct.is_cancelable() && ct.is_canceled())
					{
						STORM_RETURN_TASK_CANCELED_OPT(taskOptions, void);
					}

					auto res = epicGamesMatchmaking->SetLobbyJoinable(CEpicGamesID(epicGamesIDLobby), joinable);

					if (!res)
					{
						STORM_RETURN_TASK_FROM_EXCEPTION_OPT(std::runtime_error("EpicGames::SetLobbyJoinable Api call failed"), taskOptions, void);
					}

					return pplx::task_from_result(taskOptions);
				}

				pplx::task<void> setLobbyData(EpicGamesIDLobby epicGamesIDLobby, const std::string& key, const std::string& value, pplx::cancellation_token ct = pplx::cancellation_token::none()) override
				{
					auto actionDispatcher = _wActionDispatcher.lock();
					auto taskOptions = actionDispatcher ? pplx::task_options(actionDispatcher) : pplx::task_options();

					auto epicGamesMatchmaking = EpicGamesMatchmaking();
					if (!epicGamesMatchmaking)
					{
						STORM_RETURN_TASK_FROM_EXCEPTION_OPT(std::runtime_error("EpicGamesMatchmaking() returned null"), taskOptions, void);
					}

					if (key.size() > k_nMaxLobbyKeyLength)
					{
						STORM_RETURN_TASK_FROM_EXCEPTION_OPT(std::invalid_argument("EpicGames.SetLobbyData failed: key size too long."), taskOptions, void);
					}

					if (value.size() > k_cubChatMetadataMax)
					{
						STORM_RETURN_TASK_FROM_EXCEPTION_OPT(std::invalid_argument("EpicGames.SetLobbyData failed: value size too long."), taskOptions, void);
					}

					if (ct.is_cancelable() && ct.is_canceled())
					{
						STORM_RETURN_TASK_CANCELED_OPT(taskOptions, void);
					}

					bool res = epicGamesMatchmaking->SetLobbyData(CEpicGamesID(epicGamesIDLobby), key.c_str(), value.c_str());

					if (!res)
					{
						STORM_RETURN_TASK_FROM_EXCEPTION_OPT(std::runtime_error("epicGamesMatchmaking::SetLobbyData call returned failed."), taskOptions, void);
					}

					return pplx::task_from_result(taskOptions);
				}

				pplx::task<void> setLobbyMemberData(EpicGamesIDLobby epicGamesIDLobby, const std::string& key, const std::string& value, pplx::cancellation_token ct = pplx::cancellation_token::none()) override
				{
					auto actionDispatcher = _wActionDispatcher.lock();
					auto taskOptions = actionDispatcher ? pplx::task_options(actionDispatcher) : pplx::task_options();

					auto epicGamesMatchmaking = EpicGamesMatchmaking();
					if (!epicGamesMatchmaking)
					{
						STORM_RETURN_TASK_FROM_EXCEPTION_OPT(std::runtime_error("EpicGamesMatchmaking() returned null"), taskOptions, void);
					}

					if (key.size() > k_nMaxLobbyKeyLength)
					{
						STORM_RETURN_TASK_FROM_EXCEPTION_OPT(std::invalid_argument("EpicGames.SetLobbyData failed: key size too long."), taskOptions, void);
					}

					if (value.size() > k_cubChatMetadataMax)
					{
						STORM_RETURN_TASK_FROM_EXCEPTION_OPT(std::invalid_argument("EpicGames.SetLobbyData failed: value size too long."), taskOptions, void);
					}

					if (ct.is_cancelable() && ct.is_canceled())
					{
						STORM_RETURN_TASK_CANCELED_OPT(taskOptions, void);
					}

					epicGamesMatchmaking->SetLobbyMemberData(CEpicGamesID(epicGamesIDLobby), key.c_str(), value.c_str());

					return pplx::task_from_result(taskOptions);
				}

				pplx::task<Lobby> requestLobbyData(EpicGamesIDLobby epicGamesIDLobby, pplx::cancellation_token ct = pplx::cancellation_token::none()) override
				{
					auto actionDispatcher = _wActionDispatcher.lock();
					auto taskOptions = actionDispatcher ? pplx::task_options(actionDispatcher) : pplx::task_options();

					auto epicGamesMatchmaking = EpicGamesMatchmaking();
					if (!epicGamesMatchmaking)
					{
						STORM_RETURN_TASK_FROM_EXCEPTION_OPT(std::runtime_error("EpicGamesMatchmaking() returned null"), taskOptions, Lobby);
					}

					pplx::task_completion_event<Lobby> requestLobbyDataTce;

					auto res = epicGamesMatchmaking->RequestLobbyData(CEpicGamesID(epicGamesIDLobby));

					if (res)
					{
						std::lock_guard<std::recursive_mutex> lg(_mutex);

						_requestLobbyDataTces[epicGamesIDLobby] = requestLobbyDataTce;

						timeout(10s, ct)
							.register_callback([epicGamesIDLobby, wEpicGamesImpl = STORM_WEAK_FROM_THIS()]()
						{
							if (auto epicGamesImpl = wEpicGamesImpl.lock())
							{
								std::lock_guard<std::recursive_mutex> lg(epicGamesImpl->_mutex);

								auto it = epicGamesImpl->_requestLobbyDataTces.find(epicGamesIDLobby);
								if (it != epicGamesImpl->_requestLobbyDataTces.end())
								{
									it->second.set_exception(pplx::task_canceled());
									epicGamesImpl->_requestLobbyDataTces.erase(it);
								}
							}
						});
					}
					else
					{
						requestLobbyDataTce.set_exception(std::runtime_error("EpicGames request lobby data failed"));
					}

					return pplx::create_task(requestLobbyDataTce, taskOptions);
				}

				EpicGamesIDApp getAppId() override
				{
					auto epicGamesUtils = EpicGamesUtils();

					if (!epicGamesUtils)
					{
						return 0;
					}

					return epicGamesUtils->GetAppID();
				}

				pplx::task<std::unordered_map<EpicGamesID, std::string>> queryUserIds(const std::vector<EpicGamesID>& epicGamesIDs, pplx::cancellation_token ct = pplx::cancellation_token::none()) override
				{
					return getService([](auto, auto, auto) {}, [](auto, auto) {}, ct)
						.then([epicGamesIDs, ct](std::shared_ptr<EpicGamesService> service)
					{
						return service->queryUserIds(epicGamesIDs, ct);
					});
				}

				pplx::task<std::unordered_map<std::string, PartyDataDto>> decodePartyDataBearerTokens(const std::unordered_map<std::string, std::string>& partyDataBearerTokens, pplx::cancellation_token ct = pplx::cancellation_token::none()) override
				{
					return getService([](auto, auto, auto) {}, [](auto, auto) {}, ct)
						.then([partyDataBearerTokens, ct](std::shared_ptr<EpicGamesService> service)
					{
						return service->decodePartyDataBearerTokens(partyDataBearerTokens, ct);
					});
				}

				pplx::task<bool> inLobby(EpicGamesIDLobby epicGamesIDLobby, pplx::cancellation_token ct = pplx::cancellation_token::none()) override
				{
					return requestLobbyData(epicGamesIDLobby, ct)
						.then([epicGamesIDLobby](Lobby lobby)
					{
						auto epicGamesUser = EpicGamesUser();
						if (!epicGamesUser)
						{
							return false;
						}

						EpicGamesID epicGamesID = epicGamesUser->GetEpicGamesID().ConvertToUint64();

						for (auto& kvp : lobby.lobbyMembers)
						{
							if (kvp.first == epicGamesID)
							{
								return true;
							}
						}

						return false;
					});
				}

				pplx::task<bool> isOwner(EpicGamesIDLobby epicGamesIDLobby, pplx::cancellation_token ct = pplx::cancellation_token::none()) override
				{
					return requestLobbyData(epicGamesIDLobby, ct)
						.then([](Lobby lobby)
					{
						auto epicGamesUser = EpicGamesUser();
						if (!epicGamesUser)
						{
							return false;
						}

						auto epicGamesID = epicGamesUser->GetEpicGamesID();

						return (lobby.lobbyOwner != 0 && epicGamesID == lobby.lobbyOwner);
					});
				}

				pplx::task<std::vector<EpicGamesFriend>> getFriends(int friendsFlag = k_EFriendFlagImmediate, uint32 maxFriendsCount = UINT32_MAX, pplx::cancellation_token ct = pplx::cancellation_token::none()) override
				{
					auto task = pplx::create_task([friendsFlag, maxFriendsCount, logger = _logger]()
					{
						auto epicGamesFriends = EpicGamesFriends();
						if (!epicGamesFriends)
						{
							logger->log(LogLevel::Warn, "EpicGames.GetFriends", "EpicGamesFriends() returned nullptr");
							return std::vector<EpicGamesFriend>();
						}

						int cFriends = epicGamesFriends->GetFriendCount(friendsFlag);

						std::vector<EpicGamesFriend> friendsList;

						for (int i = 0; i < cFriends && (uint32)i < maxFriendsCount; i++)
						{
							CEpicGamesID epicGamesIDFriend = epicGamesFriends->GetFriendByIndex(i, k_EFriendFlagImmediate);

							if (epicGamesFriends->GetFriendRelationship(epicGamesIDFriend) == k_EFriendRelationshipFriend)
							{
								EpicGamesFriend epicGamesFriend;
								epicGamesFriend.epicGamesId = std::to_string(epicGamesIDFriend.ConvertToUint64());
								epicGamesFriend.relationship = "friend";
								friendsList.push_back(epicGamesFriend);
							}
						}

						return friendsList;
					});

					auto actionDispatcher = _wActionDispatcher.lock();
					auto taskOptions = actionDispatcher ? task_options(actionDispatcher, ct) : pplx::task_options(ct);
					return waitForTask<std::vector<EpicGamesFriend>>(task, taskOptions);
				}

				Event<EpicGamesIDLobby>& getJoinLobbyEvent() override
				{
					return _joinLobbyEvent;
				}

#pragma endregion

			private:

#pragma region private_methods

				void onRequestLobbyListCallResult(LobbyMatchList_t* callback, bool failure);
				CCallResult<EpicGamesImpl, LobbyMatchList_t> _requestLobbyListCallResult;

				EPICGAMES_CALLBACK(EpicGamesImpl, onLobbyDataUpdateCallback, LobbyDataUpdate_t);

				EPICGAMES_CALLBACK(EpicGamesImpl, onLobbyInviteCallback, LobbyInvite_t);

				EPICGAMES_CALLBACK(EpicGamesImpl, onGameLobbyJoinRequestedCallback, GameLobbyJoinRequested_t);

				void onLobbyEnterCallResult(LobbyEnter_t* callback, bool failure);
				EPICGAMES_CALLBACK(EpicGamesImpl, onLobbyEnterCallback, LobbyEnter_t);

				EPICGAMES_CALLBACK(EpicGamesImpl, onLobbyChatUpdateCallback, LobbyChatUpdate_t);

				void onLobbyCreatedCallResult(LobbyCreated_t* callback, bool failure);
				CCallResult<EpicGamesImpl, LobbyCreated_t> _lobbyCreatedCallResult;

				void fillLobbyData(Lobby& lobby, IEpicGamesMatchmaking* epicGamesMatchmaking)
				{
					CEpicGamesID epicGamesIDLobby(lobby.epicGamesIDLobby);

					auto numLobbyMembers = epicGamesMatchmaking->GetNumLobbyMembers(epicGamesIDLobby);
					lobby.numLobbyMembers = numLobbyMembers;

					auto lobbyMemberLimit = epicGamesMatchmaking->GetLobbyMemberLimit(epicGamesIDLobby);
					lobby.lobbyMemberLimit = lobbyMemberLimit;

					auto lobbyOwner = epicGamesMatchmaking->GetLobbyOwner(epicGamesIDLobby);
					lobby.lobbyOwner = lobbyOwner.ConvertToUint64();

					for (int member = 0; member < numLobbyMembers; member++)
					{
						auto lobbyMemberEpicGamesId = epicGamesMatchmaking->GetLobbyMemberByIndex(epicGamesIDLobby, member);

						if (lobbyMemberEpicGamesId.IsValid())
						{
							LobbyMember lobbyMember;
							lobbyMember.epicGamesID = lobbyMemberEpicGamesId.ConvertToUint64();

							auto value = epicGamesMatchmaking->GetLobbyMemberData(epicGamesIDLobby, lobbyMemberEpicGamesId, "stormancer.userId");
							if (value && strlen(value) > 0)
							{
								lobbyMember.data["stormancer.userId"] = std::string(value);
							}

							lobby.lobbyMembers.emplace(lobbyMember.epicGamesID, lobbyMember);
						}
						else
						{
							break; // We can't get lobby member informations, we skip this step
						}
					}

					auto lobbyDataCount = epicGamesMatchmaking->GetLobbyDataCount(epicGamesIDLobby);
					char key[k_nMaxLobbyKeyLength];
					char value[k_cubChatMetadataMax];
					for (int lobbyData = 0; lobbyData < lobbyDataCount; lobbyData++)
					{
						if (epicGamesMatchmaking->GetLobbyDataByIndex(epicGamesIDLobby, lobbyData, key, k_nMaxLobbyKeyLength, value, k_cubChatMetadataMax))
						{
							lobby.data.emplace(key, value);
						}
					}
				}

				std::string convertEResultToString(EResult result)
				{
					switch (result)
					{
					case k_EResultOK:
						return "OK";
					case k_EResultFail:
						return "Fail";
					case k_EResultTimeout:
						return "Timeout";
					case k_EResultLimitExceeded:
						return "LimitExceeded";
					case k_EResultAccessDenied:
						return "AccessDenied";
					case k_EResultNoConnection:
						return "NoConnection";
					default:
						return "Unknow";
					}
				}

				std::string convertEChatRoomEnterResponseToString(uint32 chatRoomEnterResponse)
				{
					switch (chatRoomEnterResponse)
					{
					case k_EChatRoomEnterResponseBanned:
						return "Banned";
					case k_EChatRoomEnterResponseClanDisabled:
						return "ClanDisabled";
					case k_EChatRoomEnterResponseCommunityBan:
						return "CommunityBan";
					case k_EChatRoomEnterResponseDoesntExist:
						return "DoesntExist";
					case k_EChatRoomEnterResponseError:
						return "Error";
					case k_EChatRoomEnterResponseLimited:
						return "Limited";
					case k_EChatRoomEnterResponseMemberBlockedYou:
						return "BlockedYou";
					case k_EChatRoomEnterResponseNotAllowed:
						return "NotAllowed";
					case k_EChatRoomEnterResponseRatelimitExceeded:
						return "RatelimitExceeded";
					case k_EChatRoomEnterResponseYouBlockedMember:
						return "YouBlockedMember";
					case k_EChatRoomEnterResponseFull:
						return "Full";
					case k_EChatRoomEnterResponseSuccess:
						return "Success";
					default:
						return "Unknow";
					}
				}

				Subscription subscribeToJoinLobbyEvent(std::function<void(EpicGamesIDLobby)> callback)
				{
					auto subscription = _joinLobbyEvent.subscribe(callback);
					// If there was an early join lobby event before the stormancer client was created
					// (typically when the game is launched because of the user joining a lobby)
					// the lobby Id of the event is cached, and the stormancer client is notified when it is ready.
					if (auto epicGamesConfig = _wEpicGamesConfig.lock())
					{
						auto connectLobby = epicGamesConfig->getConnectLobby();
						if (!connectLobby.empty())
						{
							epicGamesConfig->resetConnectLobby();
							auto epicGamesIDLobby = std::stoull(connectLobby);
							if (epicGamesIDLobby != 0)
							{
								_joinLobbyEvent(epicGamesIDLobby);
							}
						}
					}
					return subscription;
				}

#pragma endregion

#pragma region private_members

				struct LobbyEnterEventData
				{
					pplx::task_completion_event<void> tce;
					CCallResult<EpicGamesImpl, LobbyEnter_t> callResult;
				};

				pplx::cancellation_token_source _cts;
				std::recursive_mutex _mutex;
				EpicGamesIDLobby _partyEpicGamesIDLobby = 0;
				Subscription _gameConnectionStateSub;
				std::unordered_map<EpicGamesIDLobby, pplx::task_completion_event<Lobby>> _requestLobbyDataTces;
				std::shared_ptr<pplx::task_completion_event<std::vector<Lobby>>> _requestLobbyListTce; // shared_ptr is used as an optional
				std::unordered_map<EpicGamesIDLobby, LobbyEnterEventData> _lobbyEnterEventData;
				std::shared_ptr<pplx::task_completion_event<EpicGamesIDLobby>> _lobbyCreatedTce; // shared_ptr is used as an optional
				Event<EpicGamesIDLobby> _joinLobbyEvent;

				std::shared_ptr<ILogger> _logger;
				std::weak_ptr<EpicGamesConfiguration> _wEpicGamesConfig;
				std::weak_ptr<IScheduler> _wScheduler;
				std::weak_ptr<IActionDispatcher> _wActionDispatcher;
				std::weak_ptr<Users::UsersApi> _wUsersApi;
				std::weak_ptr<Party::PartyApi> _wPartyApi;


#pragma endregion
			};

			inline void EpicGamesImpl::onRequestLobbyListCallResult(LobbyMatchList_t* callback, bool failure)
			{
				_logger->log(LogLevel::Trace, "EpicGames", "Lobby list requested", "failure=" + std::to_string(failure) + " m_nLobbiesMatching=" + std::to_string(callback->m_nLobbiesMatching));

				std::lock_guard<std::recursive_mutex> lg(_mutex);

				if (failure)
				{
					_requestLobbyListTce->set_exception(std::runtime_error("EpicGames request lobby list failed"));
					return;
				}

				auto epicGamesMatchmaking = EpicGamesMatchmaking();
				if (!epicGamesMatchmaking)
				{
					_requestLobbyListTce->set_exception(std::runtime_error("EpicGamesMatchmaking() returned null"));
					return;
				}

				std::vector<Lobby> lobbies;

				for (uint32 iLobby = 0; iLobby < callback->m_nLobbiesMatching; iLobby++)
				{
					Lobby lobby;

					try
					{
						auto epicGamesIDLobby = epicGamesMatchmaking->GetLobbyByIndex(iLobby);
						lobby.epicGamesIDLobby = epicGamesIDLobby.ConvertToUint64();
						fillLobbyData(lobby, epicGamesMatchmaking);
					}
					catch (const std::exception& ex)
					{
						_requestLobbyListTce->set_exception(ex);
					}

					lobbies.push_back(lobby);
				}

				_requestLobbyListTce->set(lobbies);
			}

			inline void EpicGamesImpl::onLobbyDataUpdateCallback(LobbyDataUpdate_t* callback)
			{
				_logger->log(LogLevel::Trace, "EpicGames", std::string() + "Lobby data updated", "success=" + std::to_string(callback->m_bSuccess) + " islobby=" + std::to_string(callback->m_ulEpicGamesIDLobby == callback->m_ulEpicGamesIDMember) + " lobby=" + std::to_string(callback->m_ulEpicGamesIDLobby) + " member=" + std::to_string(callback->m_ulEpicGamesIDMember));

				if (!callback || !CEpicGamesID(callback->m_ulEpicGamesIDLobby).IsValid() || !CEpicGamesID(callback->m_ulEpicGamesIDMember).IsValid())
				{
					return;
				}

				// We only watch lobby changes for requestLobbyData calls (not user changes)
				if (callback->m_ulEpicGamesIDLobby == callback->m_ulEpicGamesIDMember) // The lobby itself changed
				{
					std::lock_guard<std::recursive_mutex> lg(_mutex);

					auto it = _requestLobbyDataTces.find(callback->m_ulEpicGamesIDLobby);
					if (it != _requestLobbyDataTces.end())
					{
						auto requestLobbyDataTce = it->second;
						_requestLobbyDataTces.erase(it);

						if (!callback->m_bSuccess)
						{
							requestLobbyDataTce.set_exception(std::runtime_error("EpicGames request lobby data failed (success == false)"));
						}

						auto epicGamesMatchmaking = EpicGamesMatchmaking();
						if (!epicGamesMatchmaking)
						{
							requestLobbyDataTce.set_exception(std::runtime_error("EpicGamesMatchmaking() returned null"));
							return;
						}

						Lobby lobby;

						try
						{
							lobby.epicGamesIDLobby = callback->m_ulEpicGamesIDLobby;
							fillLobbyData(lobby, epicGamesMatchmaking);
						}
						catch (const std::exception& ex)
						{
							requestLobbyDataTce.set_exception(ex);
							return;
						}

						requestLobbyDataTce.set(lobby);
					}
					else
					{
					}
				}
				else // Lobby member changed
				{
				}
			}

			inline void EpicGamesImpl::onGameLobbyJoinRequestedCallback(GameLobbyJoinRequested_t* callback)
			{
				if (!callback->m_epicGamesIDLobby.IsValid())
				{
					_logger->log(LogLevel::Warn, "EpicGames", "onGameLobbyJoinRequestedCallback skipped", "EpicGamesIDLobby invalid");
					return;
				}

				EpicGamesIDLobby epicGamesIDLobby = callback->m_epicGamesIDLobby.ConvertToUint64();

				_logger->log(LogLevel::Trace, "EpicGames", "Game lobby join requested", std::to_string(epicGamesIDLobby));

				_joinLobbyEvent(epicGamesIDLobby);
			}

			inline void EpicGamesImpl::onLobbyCreatedCallResult(LobbyCreated_t* callback, bool failure)
			{
				std::lock_guard<std::recursive_mutex> lg(_mutex);

				_logger->log(LogLevel::Trace, "EpicGames", "Lobby created", std::to_string(callback->m_ulEpicGamesIDLobby));

				if (failure || callback->m_eResult != EResult::k_EResultOK)
				{
					_lobbyCreatedTce->set_exception(std::runtime_error("Create lobby failed (" + convertEResultToString(callback->m_eResult) + ")"));
					return;
				}

				_lobbyCreatedTce->set(callback->m_ulEpicGamesIDLobby);
			}

			inline void EpicGamesImpl::onLobbyEnterCallback(LobbyEnter_t* callback)
			{
				onLobbyEnterCallResult(callback, false);
			}

			inline void EpicGamesImpl::onLobbyEnterCallResult(LobbyEnter_t* callback, bool failure)
			{
				_logger->log(LogLevel::Trace, "EpicGames", "Lobby entered", std::to_string(callback->m_ulEpicGamesIDLobby));

				std::lock_guard<std::recursive_mutex> lg(_mutex);

				auto it = _lobbyEnterEventData.find(callback->m_ulEpicGamesIDLobby);
				if (it != _lobbyEnterEventData.end())
				{
					if (failure || callback->m_EChatRoomEnterResponse != k_EChatRoomEnterResponseSuccess)
					{
						it->second.tce.set_exception(std::runtime_error("Enter lobby failed (" + convertEChatRoomEnterResponseToString(callback->m_EChatRoomEnterResponse) + ")"));
						return;
					}

					it->second.tce.set();
				}
			}

			inline void EpicGamesImpl::onLobbyChatUpdateCallback(LobbyChatUpdate_t* /*callback*/)
			{
			}

			inline void EpicGamesImpl::onLobbyInviteCallback(LobbyInvite_t* /*callback*/)
			{
			}

			class EpicGamesPartyProvider : public Party::Platform::IPlatformSupportProvider
			{
			public:

#pragma region public_methods

				EpicGamesPartyProvider(
					std::shared_ptr<Party::Platform::InvitationMessenger> messenger,
					std::shared_ptr<Users::UsersApi> usersApi,
					std::shared_ptr<details::EpicGamesImpl> epicGamesApi,
					std::shared_ptr<ILogger> logger,
					std::shared_ptr<Party::PartyApi> partyApi,
					std::shared_ptr<IActionDispatcher> actionDispatcher
				)
					: IPlatformSupportProvider(messenger)
					, _wUsersApi(usersApi)
					, _wEpicGamesApi(epicGamesApi)
					, _logger(logger)
					, _wPartyApi(partyApi)
					, _wActionDispatcher(actionDispatcher)
				{
				}

				std::string getPlatformName() override
				{
					return platformName;
				}

				pplx::task<std::string> getPartySceneId(const Party::PartyId& partyId, pplx::cancellation_token ct = pplx::cancellation_token::none()) override
				{
					if (partyId.type != PARTY_TYPE_EPICGAMESIDLOBBY)
					{
						assert(false);
						STORM_RETURN_TASK_FROM_EXCEPTION(std::runtime_error("Unknown PartyId type"), std::string);
					}

					std::lock_guard<std::recursive_mutex> lg(_mutex);

					auto epicGamesApi = _wEpicGamesApi.lock();

					// Get lobby data
					return epicGamesApi->requestLobbyData(std::stoull(partyId.id), ct)
						.then([wEpicGamesApi = _wEpicGamesApi, ct, logger = _logger](Lobby lobby)
					{
						auto epicGamesApi = wEpicGamesApi.lock();
						if (!epicGamesApi)
						{
							throw ObjectDeletedException("EpicGamesApi");
						}

						auto it = lobby.data.find("partyDataToken");
						if (it == lobby.data.end())
						{
							return pplx::task_from_result(std::string());
						}

						// If the "partyDataToken" metadata is found in the EpicGames lobby, we can join the associated party.
						// And if the party is joined, the server will ask to join the EpicGames lobby.
						auto partyDataToken = it->second;

						return epicGamesApi->decodePartyDataBearerTokens(std::unordered_map<std::string, std::string>{ { std::to_string(lobby.epicGamesIDLobby), partyDataToken } }, ct)
							.then([wEpicGamesApi, logger](std::unordered_map<std::string, PartyDataDto> dtos)
						{
							if (dtos.size() != 1)
							{
								throw std::runtime_error("decodePartyDataBearerTokens returned invalid result size");
							}

							auto& partyDataDto = dtos.begin()->second;

							if (partyDataDto.partyId.size() == 0)
							{
								throw std::runtime_error("Invalid partyId");
							}

							return partyDataDto.partyId;
						});
					});
				}

				pplx::task<void> createOrJoinSessionForParty(const std::string& /*partySceneId*/) override
				{
					return pplx::task_from_result();
				}

				pplx::task<void> leaveSessionForParty(const std::string& /*partySceneId*/) override
				{
					auto epicGamesApi = _wEpicGamesApi.lock();

					if (!epicGamesApi)
					{
						auto actionDispatcher = _wActionDispatcher.lock();
						auto taskOptions = actionDispatcher ? pplx::task_options(actionDispatcher) : pplx::task_options();
						STORM_RETURN_TASK_FROM_EXCEPTION_OPT(ObjectDeletedException("EpicGamesApi"), taskOptions, void);
					}

					std::lock_guard<std::recursive_mutex> lg(epicGamesApi->_mutex);

					auto partyEpicGamesIDLobby = epicGamesApi->_partyEpicGamesIDLobby;

					if (partyEpicGamesIDLobby == 0)
					{
						return pplx::task_from_result();
					}

					epicGamesApi->_partyEpicGamesIDLobby = 0;

					return epicGamesApi->leaveLobby(partyEpicGamesIDLobby);
				}

				pplx::task<void> kickPlayer(const std::string&) override
				{
					return pplx::task_from_result();
				}

				pplx::task<void> updateSessionMembers(const Party::MembersUpdate& update) override
				{
					auto epicGamesApi = _wEpicGamesApi.lock();

					auto actionDispatcher = _wActionDispatcher.lock();
					auto taskOptions = actionDispatcher ? pplx::task_options(actionDispatcher) : pplx::task_options();

					if (!epicGamesApi)
					{
						STORM_RETURN_TASK_FROM_EXCEPTION_OPT(ObjectDeletedException("EpicGamesApi"), taskOptions, void);
					}

					std::lock_guard<std::recursive_mutex> lg(epicGamesApi->_mutex);

					if (epicGamesApi->_partyEpicGamesIDLobby == 0)
					{
						return pplx::task_from_result();
					}

					auto usersApi = _wUsersApi.lock();
					if (!usersApi)
					{
						STORM_RETURN_TASK_FROM_EXCEPTION_OPT(ObjectDeletedException("UsersApi"), taskOptions, void);
					}

					auto ct = timeout(10s);

					auto myUserId = usersApi->userId();

					std::vector<pplx::task<void>> updates;
					for (auto& updatedMember : update.updatedMembers)
					{
						if (updatedMember.changes.test(Party::MembersUpdate::PromotedToLeader))
						{
							auto updateTask = epicGamesApi->isOwner(epicGamesApi->_partyEpicGamesIDLobby, ct)
								.then([update, wEpicGamesApi = _wEpicGamesApi, logger = _logger](bool isOwner)
							{
								if (!isOwner)
								{
									throw std::runtime_error("Not lobby owner");
								}

								auto scene = update.partyApi->getPartyScene();

								if (!scene)
								{
									throw std::runtime_error("Party scene is null");
								}

								auto epicGamesPartyService = scene->dependencyResolver().resolve<EpicGamesPartyService>();

								return epicGamesPartyService->createPartyDataBearerToken(timeout(10s))
									.then([wEpicGamesApi, logger](std::string dataBearerToken)
								{
									auto _epicGamesApi = wEpicGamesApi.lock();
									if (!_epicGamesApi)
									{
										STORM_RETURN_TASK_FROM_EXCEPTION(ObjectDeletedException("EpicGamesApi"), void);
									}

									return _epicGamesApi->setLobbyData(_epicGamesApi->_partyEpicGamesIDLobby, "partyDataToken", dataBearerToken, timeout(10s));
								})
									.then([logger](pplx::task<void> task)
								{
									try
									{
										return task.get();
									}
									catch (const std::exception& ex)
									{
										logger->log(LogLevel::Error, "EpicGames", ex.what());
									}
								});
							});
							updates.push_back(updateTask);
						}
					}

					return pplx::when_all(updates.begin(), updates.end());
				}

				pplx::task<void> updateSessionSettings(const Party::PartySettings& settings) override
				{
					auto actionDispatcher = _wActionDispatcher.lock();
					auto taskOptions = actionDispatcher ? pplx::task_options(actionDispatcher) : pplx::task_options();

					auto partyApi = _wPartyApi.lock();
					auto epicGamesApi = _wEpicGamesApi.lock();
					auto epicGamesMatchmaking = EpicGamesMatchmaking();
					if (partyApi && partyApi->isLeader() && epicGamesApi && epicGamesMatchmaking)
					{
						auto epicGamesIDLobbyIt = settings.publicServerData.find("EpicGamesIDLobby");
						if (epicGamesIDLobbyIt != settings.publicServerData.end())
						{
							auto epicGamesIDLobby = std::stoull(epicGamesIDLobbyIt->second);
							if (epicGamesIDLobby != 0)
							{
								_logger->log(LogLevel::Trace, "EpicGames", std::string() + "Setting lobby " + (settings.isJoinable ? "" : "not ") + "joinable", std::to_string(epicGamesIDLobby));

								return epicGamesApi->setLobbyJoinable(epicGamesIDLobby, settings.isJoinable)
									.then([settings, epicGamesIDLobby, logger = _logger]
								{
									logger->log(LogLevel::Trace, "EpicGames", std::string() + "Lobby " + (settings.isJoinable ? "" : "not ") + "joinable set", std::to_string(epicGamesIDLobby));
								});
							}
						}
					}
					return pplx::task_from_result(taskOptions);
				}

				pplx::task<std::vector<Party::AdvertisedParty>> getAdvertisedParties(pplx::cancellation_token ct = pplx::cancellation_token::none()) override
				{
					auto actionDispatcher = _wActionDispatcher.lock();
					auto taskOptions = actionDispatcher ? pplx::task_options(actionDispatcher) : pplx::task_options();

					auto epicGamesFriends = EpicGamesFriends();
					if (!epicGamesFriends)
					{
						STORM_RETURN_TASK_FROM_EXCEPTION_OPT(std::runtime_error("EpicGamesFriends() returned nullptr"), taskOptions, std::vector<Party::AdvertisedParty>);
					}

					auto epicGamesApi = _wEpicGamesApi.lock();
					if (!epicGamesApi)
					{
						STORM_RETURN_TASK_FROM_EXCEPTION_OPT(ObjectDeletedException("EpicGamesApi"), taskOptions, std::vector<Party::AdvertisedParty>);
					}

					int cFriends = epicGamesFriends->GetFriendCount(k_EFriendFlagImmediate);
					EpicGamesIDApp appId = epicGamesApi->getAppId();

					auto mapEpicGamesIDLobbyToFriend = std::make_shared<std::unordered_map<EpicGamesIDLobby, EpicGamesIDFriend>>();
					std::vector<pplx::task<EpicGames::Lobby>> lobbyTasks;

					for (int i = 0; i < cFriends; i++)
					{
						FriendGameInfo_t friendGameInfo;
						CEpicGamesID epicGamesIDFriend = epicGamesFriends->GetFriendByIndex(i, k_EFriendFlagImmediate);
						if (
							epicGamesFriends->GetFriendGamePlayed(epicGamesIDFriend, &friendGameInfo)
							&& friendGameInfo.m_gameID.IsValid()
							&& friendGameInfo.m_gameID.ToUint64() == appId
							&& friendGameInfo.m_epicGamesIDLobby.IsValid()
							)
						{
							auto epicGamesIDLobby = friendGameInfo.m_epicGamesIDLobby.ConvertToUint64();

							(*mapEpicGamesIDLobbyToFriend)[epicGamesIDLobby] = epicGamesIDFriend.ConvertToUint64();

							auto task = epicGamesApi->requestLobbyData(epicGamesIDLobby, ct);
							lobbyTasks.push_back(task);
							task.then([logger = _logger](pplx::task<EpicGames::Lobby> task)
							{
								try
								{
									task.get();
								}
								catch (const std::exception& ex)
								{
									logger->log(LogLevel::Error, "EpicGames", "Request lobby data failed", ex);
								}
							});
						}
					}

					auto advertisedParties = std::make_shared<std::vector<Party::AdvertisedParty>>();

					return pplx::when_all(lobbyTasks.begin(), lobbyTasks.end())
						.then([epicGamesApi, mapEpicGamesIDLobbyToFriend, advertisedParties, ct, logger = _logger](std::vector<EpicGames::Lobby> lobbies)
					{
						std::unordered_map<std::string, std::string> partyDataTokens;

						for (auto& lobby : lobbies)
						{
							auto it = lobby.data.find("partyDataToken");
							if (it != lobby.data.end())
							{
								auto it2 = mapEpicGamesIDLobbyToFriend->find(lobby.epicGamesIDLobby);
								if (it2 != mapEpicGamesIDLobbyToFriend->end())
								{
									auto partyDataToken = it->second;
									partyDataTokens[std::to_string(lobby.epicGamesIDLobby)] = partyDataToken;

									auto& epicGamesIDFriend = it2->second;
									Party::AdvertisedParty advertisedParty;
									advertisedParty.metadata["epicGames.epicGamesIDFriend"] = std::to_string(epicGamesIDFriend);
									advertisedParty.metadata["epicGames.epicGamesIDLobby"] = std::to_string(lobby.epicGamesIDLobby);
									advertisedParty.metadata["epicGames.lobbyOwner"] = std::to_string(lobby.lobbyOwner);
									advertisedParty.metadata["epicGames.lobbyMemberLimit"] = std::to_string(lobby.lobbyMemberLimit);
									advertisedParty.metadata["epicGames.numLobbyMembers"] = std::to_string(lobby.numLobbyMembers);
									for (auto& kvp : lobby.data)
									{
										advertisedParty.metadata["epicGames.lobbyData." + kvp.first] = kvp.second;
									}
									advertisedParties->push_back(advertisedParty);
								}
							}
						}

						auto task = partyDataTokens.size() > 0
							? epicGamesApi->decodePartyDataBearerTokens(partyDataTokens, ct)
							: pplx::task_from_result(std::unordered_map<std::string, PartyDataDto>());

						return task;
					})
						.then([epicGamesApi, advertisedParties, ct, logger = _logger](std::unordered_map<std::string, PartyDataDto> dtos)
					{
						std::vector<EpicGamesID> epicGamesIDs;

						for (auto& advertisedParty : *advertisedParties)
						{
							auto it = dtos.find(advertisedParty.metadata["epicGames.epicGamesIDLobby"]);
							if (it != dtos.end())
							{
								auto& dto = it->second;
								advertisedParty.partyId.type = Party::PartyId::TYPE_SCENE_ID;
								advertisedParty.partyId.id = dto.partyId;
								advertisedParty.leaderUserId = dto.leaderUserId;

								epicGamesIDs.push_back(std::stoull(advertisedParty.metadata["epicGames.epicGamesIDFriend"]));
							}
						}

						return epicGamesApi->queryUserIds(epicGamesIDs, ct);
					})
						.then([advertisedParties](std::unordered_map<EpicGamesID, std::string> mapEpicGamesIdToUserId)
					{
						for (auto& advertisedParty : *advertisedParties)
						{
							auto it = mapEpicGamesIdToUserId.find(std::stoull(advertisedParty.metadata["epicGames.epicGamesIDFriend"]));
							if (it != mapEpicGamesIdToUserId.end())
							{
								auto& friendId = it->second;
								advertisedParty.metadata["stormancer.friendId"] = friendId;
							}
						}

						return *advertisedParties;
					});
				}

				Subscription subscribeOnJoinPartyRequestedByPlatform(std::function<void(const Party::Platform::PlatformInvitationRequestContext&)> callback) override
				{
					auto epicGamesApi = _wEpicGamesApi.lock();
					if (!epicGamesApi)
					{
						_logger->log(LogLevel::Warn, "EpicGamesPartyProvider", "subscribeOnJoinPartyRequestedByPlatform failed", "EpicGames API deleted");
						return Subscription();
					}

					return epicGamesApi->subscribeToJoinLobbyEvent([callback, logger = _logger, wEpicGamesApi = _wEpicGamesApi](EpicGamesIDLobby epicGamesIDLobby)
					{
						if (auto epicGamesApi = wEpicGamesApi.lock())
						{
							// Get lobby data
							epicGamesApi->requestLobbyData(epicGamesIDLobby, timeout(10s))
								.then([wEpicGamesApi, logger, callback, epicGamesIDLobby](Lobby lobby)
							{
								auto epicGamesApi = wEpicGamesApi.lock();

								if (!epicGamesApi)
								{
									throw ObjectDeletedException("EpicGamesApi");
								}

								auto it = lobby.data.find("partyDataToken");
								if (it == lobby.data.end())
								{
									throw std::runtime_error("partyDataToken not found in EpicGames lobby metadata");
								}

								Party::PartyId partyId;
								partyId.platform = platformName;
								partyId.type = PARTY_TYPE_EPICGAMESIDLOBBY;
								partyId.id = std::to_string(epicGamesIDLobby);

								EpicGamesID epicGamesID = epicGamesApi->getEpicGamesID();

								Party::Platform::PlatformInvitationRequestContext ctx;
								ctx.partyId = partyId;
								ctx.invitedUser = EpicGamesPlatformUserId::create(epicGamesID);

								callback(ctx);
							})
								.then([logger, wEpicGamesApi, callback](pplx::task<void> task)
							{
								try
								{
									task.get();
								}
								catch (const std::exception& ex)
								{
									logger->log(LogLevel::Warn, "EpicGamesPartyProvider", "Game invitation ignored", ex.what());

									Party::Platform::PlatformInvitationRequestContext ctx;

									ctx.error = Party::PartyError::Str::InvalidInvitation;

									if (auto epicGamesApi = wEpicGamesApi.lock())
									{
										EpicGamesID epicGamesID = epicGamesApi->getEpicGamesID();
										ctx.invitedUser = EpicGamesPlatformUserId::create(epicGamesID);
									}

									callback(ctx);
								}
							});
						}
					});
				}

				bool tryShowSystemInvitationUI(std::shared_ptr<Party::PartyApi> partyApi) override
				{
					std::lock_guard<std::recursive_mutex> lg(_mutex);

					auto epicGamesFriends = EpicGamesFriends();
					if (!epicGamesFriends)
					{
						_logger->log(LogLevel::Error, "EpicGames", "EpicGamesFriends() returned nullptr");
						return false;
					}

					if (!partyApi->isInParty())
					{
						_logger->log(LogLevel::Error, "EpicGames", "Not in a party");
						return false;
					}

					auto epicGamesApi = _wEpicGamesApi.lock();

					if (!epicGamesApi)
					{
						_logger->log(LogLevel::Error, "EpicGames", "EpicGamesApi deleted");
						return false;
					}

					auto partyEpicGamesIDLobby = epicGamesApi->_partyEpicGamesIDLobby;

					if (partyEpicGamesIDLobby == 0)
					{
						_logger->log(LogLevel::Error, "EpicGames", "Not in a lobby");
						return false;
					}

					epicGamesFriends->ActivateGameOverlayInviteDialog(CEpicGamesID(partyEpicGamesIDLobby));

					return true;
				}

#pragma endregion

#pragma region private_members

			private:

				std::recursive_mutex _mutex;
				std::shared_ptr<ILogger> _logger;
				std::weak_ptr<Users::UsersApi> _wUsersApi;
				std::weak_ptr<details::EpicGamesImpl> _wEpicGamesApi;
				std::weak_ptr<Party::PartyApi> _wPartyApi;
				std::weak_ptr<IActionDispatcher> _wActionDispatcher;

#pragma endregion
			};
		}

		// https://dev.epicgames.com/docs/services/en-US/WebAPIRef/AuthWebAPI/index.html

		class EpicGamesAuthenticationEventHandler : public std::enable_shared_from_this<EpicGamesAuthenticationEventHandler>, public Users::IAuthenticationEventHandler
		{
		public:

#pragma region public_methods

			EpicGamesAuthenticationEventHandler(std::shared_ptr<details::EpicGamesConfiguration> epicGamesConfig)
				: _epicGamesConfiguration(epicGamesConfig)
			{
			}

			pplx::task<void> retrieveCredentials(const Users::CredentialsContext& context) override
			{
				return getEpicGamesCredentials([context](std::string type, std::string provider, std::string epicGamesTicketHex)
				{
					context.authParameters->type = type;
					context.authParameters->parameters["provider"] = provider;
					context.authParameters->parameters["ticket"] = epicGamesTicketHex;
				});
			}

			virtual pplx::task<void> renewCredentials(const Users::CredentialsRenewalContext& context) override
			{
				return getEpicGamesCredentials([context](std::string type, std::string provider, std::string epicGamesTicketHex)
				{
					context.response->parameters["provider"] = provider;
					context.response->parameters["ticket"] = epicGamesTicketHex;
				});
			}

			pplx::task<void> getEpicGamesCredentials(std::function<void(std::string type, std::string provider, std::string epicGamesTicketHex)> fulfillCredentialsCallback)
			{
				if (!_epicGamesConfiguration->getAuthenticationEnabled())
				{
					return pplx::task_from_result();
				}

				if (!EpicGamesAPI_IsEpicGamesRunning())
				{
					throw std::runtime_error("EpicGames is not running");
				}

				std::lock_guard<std::recursive_mutex> lg(_mutex);

				if (_authTce)
				{
					_authTce->set_exception(pplx::task_canceled());
				}

				_authTce = std::make_shared<pplx::task_completion_event<void>>();

				timeout(10s)
					.register_callback([tce = _authTce]()
				{
					tce->set_exception(pplx::task_canceled());
				});

				std::string epicGamesTicketHex;

				std::shared_ptr<std::vector<byte>> epicGamesTicket;

				auto epicGamesUser = EpicGamesUser();
				if (!epicGamesUser)
				{
					throw std::runtime_error("EpicGamesUser() returned null");
				}

				epicGamesTicket = std::make_shared<std::vector<byte>>(1024);

				auto pcbTicket = std::make_shared<uint32>(0);
				auto hAuthTicket = epicGamesUser->GetAuthSessionTicket(epicGamesTicket->data(), (int)epicGamesTicket->size(), pcbTicket.get());

				if (hAuthTicket == k_HAuthTicketInvalid)
				{
					throw std::runtime_error("EpicGames : invalid user authentication ticket");
				}

				return pplx::create_task(*_authTce)
					.then([fulfillCredentialsCallback, epicGamesTicket]()
				{
					std::stringstream ss;
					ss << std::uppercase << std::hex << std::setfill('0');
					for (auto b : *epicGamesTicket)
					{
						ss << std::setw(2) << static_cast<unsigned>(b);
					}
					auto epicGamesTicketHex = ss.str();

					fulfillCredentialsCallback(platformName, platformName, epicGamesTicketHex);
				});
			}

#pragma endregion

		private:

#pragma region private_methods

			EPICGAMES_CALLBACK(EpicGamesAuthenticationEventHandler, onAuthSessionTicket, GetAuthSessionTicketResponse_t);

#pragma endregion

#pragma region private_members

			std::recursive_mutex _mutex;
			std::shared_ptr<details::EpicGamesConfiguration> _epicGamesConfiguration;
			std::shared_ptr<pplx::task_completion_event<void>> _authTce; // shared_ptr used as an optional

#pragma endregion
		};

		inline void EpicGamesAuthenticationEventHandler::onAuthSessionTicket(GetAuthSessionTicketResponse_t* callback)
		{
			std::lock_guard<std::recursive_mutex> lg(_mutex);

			if (callback->m_eResult != EResult::k_EResultOK)
			{
				_authTce->set_exception(std::runtime_error("EpicGames GetAuthSessionTicket failed : EResult = " + std::to_string((int)callback->m_eResult)));
			}

			if (callback->m_hAuthTicket == k_HAuthTicketInvalid)
			{
				_authTce->set_exception(std::runtime_error("EpicGames GetAuthSessionTicket failed : Invalid user authentication ticket"));
			}

			_authTce->set();
		}

		class EpicGamesPlugin : public IPlugin
		{
		public:

			static constexpr const char* PLUGIN_NAME = "EpicGames";
			static constexpr const char* PLUGIN_VERSION = "1.0.0";

			PluginDescription getDescription() override
			{
				return PluginDescription(PLUGIN_NAME, PLUGIN_VERSION);
			}

		private:

			void registerClientDependencies(ContainerBuilder& builder) override
			{
				builder.registerDependency<details::EpicGamesConfiguration, Configuration>().singleInstance();
				builder.registerDependency<details::EpicGamesImpl, Users::UsersApi, details::EpicGamesConfiguration, Configuration, IScheduler, ILogger, Party::PartyApi>().asSelf().as<EpicGamesApi>().singleInstance();
				builder.registerDependency<details::EpicGamesPartyProvider, Party::Platform::InvitationMessenger, Users::UsersApi, details::EpicGamesImpl, ILogger, Party::PartyApi, IActionDispatcher>().as<Party::Platform::IPlatformSupportProvider>();
				builder.registerDependency<EpicGamesAuthenticationEventHandler, details::EpicGamesConfiguration>().as<Users::IAuthenticationEventHandler>();
			}

			void clientCreated(std::shared_ptr<IClient> client)
			{
				auto epicGamesApi = client->dependencyResolver().resolve<EpicGamesApi>();
				epicGamesApi->initialize();
			}

			void registerSceneDependencies(ContainerBuilder& builder, std::shared_ptr<Scene> scene) override
			{
				if (scene->getHostMetadata(EpicGamesApi::METADATA_KEY).length() > 0)
				{
					builder.registerDependency<details::EpicGamesService, Scene>();
				}

				if (scene->getHostMetadata(Party::details::PartyService::METADATA_KEY).length() > 0)
				{
					builder.registerDependency<details::EpicGamesPartyService, Scene>();
				}
			}
		};
	}
}

MSGPACK_ADD_ENUM(ELobbyType);
